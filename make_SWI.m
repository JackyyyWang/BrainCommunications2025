% Matthew J. Cronin 2020 - matthew.j.cronin@gmail.com
clear all
close all
clc

padsize=[12 12 12]; % PADDING VARIABLE, CAN BE LEFT AS IS

TE=[15];% YOUR ECHO TIME(S) IN ms

Erode_extra_N=0; % CONTROLS NUMBER OF EROSION STEPS ON PHASE MASK,
                 % THIS STEP IS OPTIONAL - USED TO ELIMINATE BAD PHASE AT
                 % EDGES
                 
B0=7; % B0 FIELD STRENGTH
                 
path=['/home/jc/Documents/VUMC_MS_matlab_script/FLAIR-SWI']; % PATH TO YOUR DATA

cd(path)

procdir=[path,'/processing'];

[a,b]=unix(['mkdir ',procdir]);

[a,in]=unix('ls *SWI*01.nii'); % Find file name string - pattern must match gStudy output
[mag_DATA]=load_untouch_nii(in(1:end-1)); % INPUT - STRAIGHTENED MAGNITUDE DATA

% Data reads in as type int16, must be converted single- or 
% double-precision floating-point.
mag=single(mag_DATA.img); 

[a,in]=unix('ls *SWI*ph.nii');
[phase_DATA]=load_untouch_nii(in(1:end-1)); % INPUT - STRAIGHTENED MAGNITUDE DATA
phase=single(phase_DATA.img);

% Phase data is sometimes read in with an arbitrary scaling. In this case
% it currently reads in scaled between 0 and some positive maximum. We 
% expect and require raw phase data to be wrapped between -pi and +pi, and 
% so we scale and shift the data to meet this criteria.
phase=phase.*2*pi./max(phase(:))-pi;
% 
% The output of this line must be verified and the command itself probably
% changed if a different NIFTI reading tool is used (currently
% load_untouch_nii() )
voxelsize=phase_DATA.hdr.dime.pixdim(2:4);


%% For Fourier transforms used in high-pass filtering to behave correctly, 
% data must have an even number of elements along each dimension.

% % In some cases the phase information generated by the scanner is
% corrupt. In others, the real and imaginary data have some arbitraty bias
% such that tehy are not fluctuating about 0 as expected. In the case of
% bad phaes but good real/imaginary data, phase and magnituse images can be
% calculated form real and imaginary.  ALWAYS vizualize output when making
% changes to the processing pipeline to verify that results are plausible.

% re=re(:,:,1:end-1);
% im=im(:,:,1:end-1);

% mag=abs(squeeze(re+1i*im));
% phase=angle(squeeze(re+1i*im));


mag=mag(:,:,1:end-1);
phase=phase(:,:,1:end-1);

dims=size(mag);

%%

% Here I create a binary mask from the skull-stripped brain. Using the -m
% flag when running the FSL brain extraction tool (bet) will output a
% binary mask for you and that can just be loaded in here without the
% second line

cd(procdir)

m_nii=make_nii(mag);
save_nii(m_nii,'m_vol.nii');
[a,b]=unix('/usr/local/fsl/bin/bet2 m_vol.nii m_brain -f 0.3 -n -m');

[DATA]=load_nii('m_brain.nii_mask.nii.gz');

mask=single(DATA.img~=0);

%% For Fourier transforms used in high-pass filteringto behave correctly, 
% data must have an even number of elements along each dimension.
    
% mask=mask(:,:,1:end-1);

%%

% % Unwrap phase using your chosen algorithm
% uwphase=MRPhaseUnwrap(phase,'voxelsize',voxelsize,'padsize',padsize);
% uwPhase=make_nii(filt_phase);
% uwPhase.hdr.dime.dim=mag_DATA.hdr.dime.dim;
% uwPhase.hdr.dime.dim(2:4)=dims;
% uwPhase.hdr.dime.pixdim=mag_DATA.hdr.dime.pixdim;
% uwPhase.hdr.dime.vox_offset=mag_DATA.hdr.dime.vox_offset;
% save_nii(uwPhase, 'smooth_uw.nii')

%%

% To remove background fields and phase wraps, the data is high-pass
% filtered using a Hanning filter as described in the original paper
% "Susceptibility weighted imaging (SWI)" by Haacke et al 
% ( DOI 10.1002/mrm.20198 ). Disregard claims of quantitative measurements
% made by Haacke with regard to iron content based on tissue phase/SWI. See
% Cronin et al, 2015 ( DOI 10.1007/s10334-016-0560-5 ) for some discussion
% of this.

filt_phase=hann_filt(mag,phase,60);
Phase=make_nii(filt_phase);

% sigma = 3.9;
% 
% 
% volSmooth = imgaussfilt3(filt_phase, sigma, FilterSize=31);
% volSmoothI = make_nii(volSmooth);
% volSmoothI.hdr.dime.dim=mag_DATA.hdr.dime.dim;
% volSmoothI.hdr.dime.dim(2:4)=dims;
% volSmoothI.hdr.dime.pixdim=mag_DATA.hdr.dime.pixdim;
% volSmoothI.hdr.dime.vox_offset=mag_DATA.hdr.dime.vox_offset;
% save_nii(volSmoothI, 'smooth_Phase_FWHM.nii')


Phase.hdr.dime.dim=mag_DATA.hdr.dime.dim;
Phase.hdr.dime.dim(2:4)=dims;
Phase.hdr.dime.pixdim=mag_DATA.hdr.dime.pixdim;
Phase.hdr.dime.vox_offset=mag_DATA.hdr.dime.vox_offset;
disp(mag_DATA.hdr.dime)
save_nii(Phase,'Phase.nii')




% This should be optimized for the spine data, however if the filt_phase is
% insufficiently unwrapped or looks way too flat, you an try playing wiht
% the filter width (optimized value is currently 20)

% The filter width in number of points will have significantly different
% effects if the FOV and/or spatial resolution of the data is different to
% that for which the parameter was optimized. A better, physically
% consistent method of describing filter width is presented by Walsh and
% Wilman (NeuroImage, 2011) ( doi:10SWI_nii.hdr.dime.dim=mag_DATA.hdr.dime.dim;


%% Calculate SWI mask - -ve phase voxels do not alter magnitude, +ve phase voxels attenuate magnitude

SWI_mask=zeros(size(phase));

% Create mask where phase>=thresh = 1 and negative phase goes linearly from 1->0
% from phase=0 -> -pi

% `thresh` should be fine left at 0 for brain data. Its purpose was to keep
% the SWI mask threshold above the noise level in spinal cord SWI, where a
% setting of 0 results in a SWI mask dominated by random noise rather thatn
% features of interest.
thresh=0; % PLAY WITH THIS!!!

for ii=1:dims(1)
    for jj=1:dims(2)
        for kk=1:dims(3)
%             if mask(ii,jj,kk)==1
                if filt_phase(ii,jj,kk)<thresh
                    SWI_mask(ii,jj,kk)=1;
                else
                    SWI_mask(ii,jj,kk)=1-((filt_phase(ii,jj,kk)-thresh)./pi);
                end
%             end
        end
    end
end

% Raise mask to power n to increase contrast PLAY WITH THIS!!!
SWI_mask=SWI_mask.^5;

SWI_img=mag.*SWI_mask; % MAKE THE SWI!!!

% This is a crude way to make a new NIFTI header file and sub in key
% parameters which describe spatial resolution and FOV etc. You may try
% changing this, but bear in mind that input/output of NIFTI data has
% caused the majority of problems I've experienced building this processing
% pipeline.
SWI_mask_nii=make_nii(SWI_mask);
SWI_mask_nii.hdr.dime.dim=mag_DATA.hdr.dime.dim;
SWI_mask_nii.hdr.dime.dim(2:4)=dims;
SWI_mask_nii.hdr.dime.pixdim=mag_DATA.hdr.dime.pixdim;
SWI_mask_nii.hdr.dime.vox_offset=mag_DATA.hdr.dime.vox_offset;
save_nii(SWI_mask_nii,'SWI_mask.nii');


new_mag_nii=make_nii(mag);
new_mag_nii.hdr.dime.dim=mag_DATA.hdr.dime.dim;
new_mag_nii.hdr.dime.dim(2:4)=dims;
new_mag_nii.hdr.dime.pixdim=mag_DATA.hdr.dime.pixdim;
new_mag_nii.hdr.dime.vox_offset=mag_DATA.hdr.dime.vox_offset;
save_nii(new_mag_nii,'mag_cropped.nii');

SWI_nii=make_nii(SWI_img);
SWI_nii.hdr.dime.dim=mag_DATA.hdr.dime.dim;
SWI_nii.hdr.dime.dim(2:4)=dims;
SWI_nii.hdr.dime.pixdim=mag_DATA.hdr.dime.pixdim;
SWI_nii.hdr.dime.vox_offset=mag_DATA.hdr.dime.vox_offset;
save_nii(SWI_nii,'SWI.nii');



[a,b]=unix(['cp ',fullfile(path,'*FLAIR*.nii '),fullfile(procdir,'FLAIR.nii')]);

cd(procdir)
reg=['flirt -in FLAIR.nii -ref mag_cropped.nii -out FLAIR_reg_SWI.nii',...
    ' -omat FLAIR_reg_SWI.mat -searchrx -15 15 -searchry -15 15 ',...
    '-searchrz -15 15 -cost mutualinfo'];
[a,b]=unix(reg);

[a,b]=unix('/usr/local/fsl/bin/bet2 FLAIR_reg_SWI.nii.gz FLAIR_reg_SWI_brain.nii.gz -m -f 0.2');
%%
% !gunzip FLAIR_reg_SWI_brain.nii.gz
flair=niftiread('FLAIR_reg_SWI_brain.nii.gz');
% 
flair_info=niftiinfo('FLAIR_reg_SWI_brain.nii.gz');

% !gunzip FLAIR_reg_SWI_brain_mask.nii.gz
mask=niftiread('FLAIR_reg_SWI_brain.nii.gz_mask.nii.gz');

% mask=flair~=0;

mask_er=mask;
for n=1:2
    mask_er=imerode(mask_er,ones(3,3,3));
end

tic;
pfit = getpolyfit3_fast_gap(flair,mask_er,6,3);
toc;

flair_filt=(flair-pfit);
flair_filt=flair_filt-min(flair_filt(:));

pfit_red=pfit./1e6;

pow_mask=1+exp(-pfit_red).*single(mask_er);

flair_mod=flair.^(pow_mask.^0.48);
% figure;imagesc(squeeze(flair_mod(:,:,24)),[0 2.5e7]);colormap gray;axis image

% flairmont=myMontage(flair_mod);
% figure;imagesc(flairmont,[0,3e7]);colormap gray; axis image

flair_SWI=flair_mod.*SWI_mask;
% flair_mod=reslice(flair_mod,2);
niftiwrite(flair_mod,'PostGad_FLAIR_flat.nii',flair_info)

niftiwrite(flair_SWI,'PostGad_FLAIR_SWI.nii',flair_info)

%% MIP

mip_depth=3;
step=mip_depth-1;
SWI_MIP=zeros(dims(1),dims(2),dims(3)-step);

for n=1:size(SWI_MIP,3)
   SWI_MIP(:,:,n)=min(SWI_img(:,:,n:n+step),[],3);
end



 
